<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Hoodie Viewer with UV Region Stickers</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
    #viewer { width: 100vw; height: 100vh; }
    #controls {
      position: absolute; top: 10px; left: 10px; z-index: 100;
      background: rgba(255,255,255,0.8); padding: 10px; border-radius: 5px;
      max-width: 300px;
    }
    #loading-overlay {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.8); display: flex; flex-direction: column;
      justify-content: center; align-items: center; color: white; z-index: 100;
    }
    .spinner {
      width: 40px; height: 40px; border: 4px solid rgba(255,255,255,0.3);
      border-radius: 50%; border-top-color: #4361ee;
      animation: spin 1s ease-in-out infinite; margin-bottom: 15px;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    #status { margin-top: 10px; font-size: 1em; }
    #uv-regions {
      margin-top: 10px;
      max-height: 200px;
      overflow-y: auto;
    }
    .uv-region {
      padding: 5px;
      margin: 2px 0;
      background: #eee;
      cursor: pointer;
    }
    .uv-region:hover {
      background: #ddd;
    }
    .uv-region.active {
      background: #4361ee;
      color: white;
    }
  </style>
</head>
<body>
  <div id="controls">
    <input type="file" id="sticker-upload" accept="image/*">
    <div>Position: <input type="range" id="position-x" min="0" max="2" step="0.01" value="1.5"> X</div>
    <div>Position: <input type="range" id="position-y" min="-1" max="2" step="0.01" value="1.32"> Y</div>
    <div>Scale: <input type="range" id="scale" min="0.1" max="2" step="0.05" value="0.5"></div>
    <div>Rotation: <input type="range" id="rotation" min="0" max="6.28" step="0.1" value="0"></div>
    <div id="uv-regions">
      <p>Select UV Region:</p>
      <!-- UV regions will be populated dynamically -->
    </div>
  </div>
  
  <div id="loading-overlay">
    <div class="spinner"></div>
    <div id="status">Loading 3D Hoodie Viewer...</div>
  </div>
  <div id="viewer"></div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';

    let scene, camera, renderer, controls, hoodieModel, mixer, clock;
    let decalMaterial, currentStickerTexture = null;
    let currentUVRegion = null;

    // Define UV regions based on your specific coordinates
    const predefinedUVRegions = [
      { 
        id: 'front', 
        name: 'Front Main', 
        u: 0.5, 
        v: 0.5, 
        width: 0.5, 
        height: 0.5 
      },
      { 
        id: 'back', 
        name: 'Back Main', 
        u: 0.25, 
        v: 1.38, 
        width: 0.5, 
        height: 0.5 
      },
      { 
        id: 'sleeve_right', 
        name: 'Right Sleeve', 
        u: 1.41, 
        v: 0.21, 
        width: 0.3, 
        height: 0.3 
      },
      { 
        id: 'sleeve_left', 
        name: 'Left Sleeve', 
        u: 0.81, 
        v: -0.50, 
        width: 0.3, 
        height: 0.3 
      },
      { 
        id: 'hood', 
        name: 'Hood', 
        u: -0.50, 
        v: -0.20, 
        width: 0.4, 
        height: 0.4 
      }
    ];

    init();

    function init() {
      // Setup scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf0f0f0);

      // Setup camera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 5;

      // Setup renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.getElementById('viewer').appendChild(renderer.domElement);

      // Lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(1, 1, 1);
      scene.add(directionalLight);

      // Controls
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      // Clock for animations
      clock = new THREE.Clock();

      // UI Event Listeners
      document.getElementById('sticker-upload').addEventListener('change', handleStickerUpload);
      document.getElementById('position-x').addEventListener('input', updateDecal);
      document.getElementById('position-y').addEventListener('input', updateDecal);
      document.getElementById('scale').addEventListener('input', updateDecal);
      document.getElementById('rotation').addEventListener('input', updateDecal);

      // Initialize UV regions UI
      initUVRegions();

      // Load model
      loadModel();

      // Start animation loop
      animate();

      // Handle window resize
      window.addEventListener('resize', onWindowResize);
    }

    function initUVRegions() {
      const uvRegionsContainer = document.getElementById('uv-regions');
      
      predefinedUVRegions.forEach(region => {
        const regionElement = document.createElement('div');
        regionElement.className = 'uv-region';
        regionElement.textContent = region.name;
        regionElement.dataset.id = region.id;
        
        regionElement.addEventListener('click', () => {
          // Set active state
          document.querySelectorAll('.uv-region').forEach(el => el.classList.remove('active'));
          regionElement.classList.add('active');
          
          // Set current UV region
          currentUVRegion = region;
          
          // Update sliders to match this region's center
          document.getElementById('position-x').value = region.u;
          document.getElementById('position-y').value = region.v;
          
          // Update decal
          updateDecal();
        });
        
        uvRegionsContainer.appendChild(regionElement);
      });
      
      // Select first region by default
      if (predefinedUVRegions.length > 0) {
        currentUVRegion = predefinedUVRegions[0];
        document.querySelector('.uv-region').classList.add('active');
        document.getElementById('position-x').value = currentUVRegion.u;
        document.getElementById('position-y').value = currentUVRegion.v;
      }
    }

    async function loadModel() {
      updateStatus('Loading hoodie model...');
      
      try {
        const loader = new GLTFLoader();
        const dracoLoader = new DRACOLoader();
        dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
        loader.setDRACOLoader(dracoLoader);
        
        const gltf = await loader.loadAsync('Hoodie_Walking_Animated.glb');
        hoodieModel = gltf.scene;
        scene.add(hoodieModel);

        // Setup animations if available
        if (gltf.animations && gltf.animations.length > 0) {
          mixer = new THREE.AnimationMixer(hoodieModel);
          mixer.clipAction(gltf.animations[0]).play();
          updateStatus('Model loaded with animation');
        } else {
          updateStatus('Model loaded');
        }

        // Create a default white texture
        const defaultTexture = createDefaultTexture();
        
        // Create decal material with support for UV regions
        decalMaterial = createDecalMaterial(defaultTexture);
        
        // Apply material to all meshes
        hoodieModel.traverse((child) => {
          if (child.isMesh) {
            child.material = decalMaterial;
          }
        });

        // Center model
        const box = new THREE.Box3().setFromObject(hoodieModel);
        const center = box.getCenter(new THREE.Vector3());
        hoodieModel.position.sub(center);
        camera.position.z = box.getSize(new THREE.Vector3()).length() * 1.5;
        controls.update();

        // Hide loading overlay
        document.getElementById('loading-overlay').style.display = 'none';
      } catch (error) {
        updateStatus('Failed to load model');
        console.error(error);
        createFallbackModel();
      }
    }

    function createDefaultTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = canvas.height = 2;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = '#4361ee';
      ctx.fillRect(0, 0, 2, 2);
      return new THREE.CanvasTexture(canvas);
    }

    function createDecalMaterial(baseTexture) {
      return new THREE.ShaderMaterial({
        uniforms: {
          baseTexture: { value: baseTexture },
          decalTexture: { value: null },
          decalPosition: { value: new THREE.Vector2(0.5, 0.5) },
          decalScale: { value: 0.5 },
          decalRotation: { value: 0 },
          useDecal: { value: false },
          uvRegion: { value: new THREE.Vector4(0, 0, 1, 1) } // x, y, width, height
        },
        vertexShader: `
          varying vec2 vUV;
          void main() {
            vUV = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform sampler2D baseTexture;
          uniform sampler2D decalTexture;
          uniform vec2 decalPosition;
          uniform float decalScale;
          uniform float decalRotation;
          uniform bool useDecal;
          uniform vec4 uvRegion; // x, y, width, height
          varying vec2 vUV;

          void main() {
            vec4 baseColor = texture2D(baseTexture, vUV);
            
            if (useDecal) {
              // Check if current UV is within the active region
              if (vUV.x >= uvRegion.x && vUV.x <= (uvRegion.x + uvRegion.z) &&
                  vUV.y >= uvRegion.y && vUV.y <= (uvRegion.y + uvRegion.w)) {
                
                // Normalize UV coordinates within the region
                vec2 regionUV = (vUV - uvRegion.xy) / uvRegion.zw;
                
                // Transform to decal space
                vec2 center = vec2(0.5);
                vec2 uv = regionUV - center;
                
                // Apply rotation
                float cosRot = cos(decalRotation);
                float sinRot = sin(decalRotation);
                uv = vec2(
                  uv.x * cosRot - uv.y * sinRot,
                  uv.x * sinRot + uv.y * cosRot
                );
                
                // Apply scale and position
                uv = uv / decalScale + decalPosition;
                
                if (uv.x >= 0.0 && uv.x <= 1.0 && uv.y >= 0.0 && uv.y <= 1.0) {
                  vec4 decalColor = texture2D(decalTexture, uv);
                  baseColor = mix(baseColor, decalColor, decalColor.a);
                }
              }
            }
            
            gl_FragColor = baseColor;
          }
        `,
        transparent: true
      });
    }

    function handleStickerUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {
          currentStickerTexture = new THREE.Texture(img);
          currentStickerTexture.needsUpdate = true;
          
          decalMaterial.uniforms.decalTexture.value = currentStickerTexture;
          decalMaterial.uniforms.useDecal.value = true;
          
          // Set UV region based on current selection
          if (currentUVRegion) {
            decalMaterial.uniforms.uvRegion.value.set(
              currentUVRegion.u - currentUVRegion.width/2,
              currentUVRegion.v - currentUVRegion.height/2,
              currentUVRegion.width,
              currentUVRegion.height
            );
          }
          
          updateDecal();
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    }

    function updateDecal() {
      if (!decalMaterial) return;
      
      const posX = parseFloat(document.getElementById('position-x').value);
      const posY = parseFloat(document.getElementById('position-y').value);
      const scale = parseFloat(document.getElementById('scale').value);
      const rotation = parseFloat(document.getElementById('rotation').value);
      
      decalMaterial.uniforms.decalPosition.value.set(posX, posY);
      decalMaterial.uniforms.decalScale.value = scale;
      decalMaterial.uniforms.decalRotation.value = rotation;
      
      // Update UV region if one is selected
      if (currentUVRegion) {
        decalMaterial.uniforms.uvRegion.value.set(
          currentUVRegion.u - currentUVRegion.width/2,
          currentUVRegion.v - currentUVRegion.height/2,
          currentUVRegion.width,
          currentUVRegion.height
        );
      }
      
      decalMaterial.needsUpdate = true;
    }

    function createFallbackModel() {
      const geometry = new THREE.BoxGeometry(1, 1, 1);
      const material = new THREE.MeshBasicMaterial({ color: 0x4361ee });
      hoodieModel = new THREE.Mesh(geometry, material);
      scene.add(hoodieModel);
      
      document.getElementById('loading-overlay').style.display = 'none';
    }

    function updateStatus(msg) {
      document.getElementById('status').textContent = msg;
      console.log(msg);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      if (mixer) mixer.update(delta);
      controls.update();
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
