<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Hoodie Viewer with Decals</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
    #viewer { width: 100vw; height: 100vh; }
    #controls {
      position: absolute; top: 10px; left: 10px; z-index: 100;
      background: rgba(255,255,255,0.8); padding: 10px; border-radius: 5px;
      max-height: 80vh; overflow-y: auto; width: 300px;
    }
    #loading-overlay {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.8); display: flex; flex-direction: column;
      justify-content: center; align-items: center; color: white; z-index: 100;
    }
    .spinner {
      width: 40px; height: 40px; border: 4px solid rgba(255,255,255,0.3);
      border-radius: 50%; border-top-color: #4361ee;
      animation: spin 1s ease-in-out infinite; margin-bottom: 15px;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    #status { margin-top: 10px; font-size: 1em; }
    .sticker-controls {
      border: 1px solid #ddd; padding: 10px; margin-top: 10px;
      border-radius: 5px; background: rgba(255,255,255,0.7);
    }
    .sticker-header {
      display: flex; justify-content: space-between;
      margin-bottom: 5px; font-weight: bold;
    }
    .remove-sticker {
      color: red; cursor: pointer;
    }
    #add-sticker-btn {
      margin-top: 10px; padding: 5px 10px;
      background: #4361ee; color: white;
      border: none; border-radius: 3px;
      cursor: pointer;
    }
    #animation-controls {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 100;
      background: rgba(255,255,255,0.8);
      padding: 10px;
      border-radius: 5px;
    }
    #animation-toggle {
      padding: 5px 10px;
      background: #4361ee;
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
    }
    #color-controls {
      position: absolute;
      top: 60px;
      right: 10px;
      z-index: 100;
      background: rgba(255,255,255,0.8);
      padding: 10px;
      border-radius: 5px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    #color-presets {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 5px;
    }
    .color-preset {
      width: 30px;
      height: 30px;
      border: 1px solid #ccc;
      cursor: pointer;
    }
    #apply-color-btn {
      padding: 5px 10px;
      background: #4361ee;
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
    }
    .size-controls {
      margin-top: 10px;
    }
    .size-controls input {
      width: 100%;
    }
    #instructions {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255,255,255,0.8);
      padding: 10px;
      border-radius: 5px;
      z-index: 100;
      text-align: center;
    }
  </style>
</head>
<body>
  <div id="controls">
    <div id="sticker-controls-container">
      <div class="sticker-controls">
        <div class="sticker-header">
          <span>Current Decal</span>
        </div>
        <input type="file" id="sticker-upload" accept="image/*">
        <div class="size-controls">
          <div>Size: <input type="range" id="decal-size" min="0.1" max="1" step="0.05" value="0.3"></div>
          <div>Rotation: <input type="range" id="decal-rotation" min="0" max="6.28" step="0.1" value="0"></div>
        </div>
      </div>
    </div>
  </div>
  
  <div id="animation-controls">
    <button id="animation-toggle">Pause Animation</button>
  </div>
  
  <div id="color-controls">
    <label for="hoodieColor">Hoodie Color:</label>
    <input type="color" id="hoodieColor" value="#4361ee">
    <div id="color-presets">
      <div class="color-preset" style="background-color: #4361ee;" data-color="#4361ee"></div>
      <div class="color-preset" style="background-color: #3a0ca3;" data-color="#3a0ca3"></div>
      <div class="color-preset" style="background-color: #7209b7;" data-color="#7209b7"></div>
      <div class="color-preset" style="background-color: #f72585;" data-color="#f72585"></div>
      <div class="color-preset" style="background-color: #4cc9f0;" data-color="#4cc9f0"></div>
      <div class="color-preset" style="background-color: #4895ef;" data-color="#4895ef"></div>
      <div class="color-preset" style="background-color: #3f37c9;" data-color="#3f37c9"></div>
      <div class="color-preset" style="background-color: #560bad;" data-color="#560bad"></div>
    </div>
    <button id="apply-color-btn">Apply Color</button>
  </div>
  
  <div id="instructions">
    Upload an image, then click anywhere on the hoodie to place it
  </div>
  
  <div id="loading-overlay">
    <div class="spinner"></div>
    <div id="status">Loading 3D Hoodie Viewer...</div>
  </div>
  <div id="viewer"></div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
    import { DecalGeometry } from 'three/addons/geometries/DecalGeometry.js';

    let scene, camera, renderer, controls, hoodieModel, mixer, clock;
    let hoodieMaterial;
    let decalMeshes = [];
    let isAnimationPlaying = true;
    let currentAnimationAction = null;
    let uploadedTexture = null;
    let currentDecalSize = 0.3;
    let currentDecalRotation = 0;
    
    // For raycasting
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    init();

    function init() {
      // Setup scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf0f0f0);

      // Setup camera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 5;

      // Setup renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      document.getElementById('viewer').appendChild(renderer.domElement);

      // Lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(1, 1, 1);
      directionalLight.castShadow = true;
      scene.add(directionalLight);

      // Controls
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      // Clock for animations
      clock = new THREE.Clock();

      // Add event listener for image upload
      document.getElementById('sticker-upload').addEventListener('change', handleStickerUpload);

      // Add event listener for animation toggle
      document.getElementById('animation-toggle').addEventListener('click', toggleAnimation);

      // Add event listeners for color controls
      document.getElementById('apply-color-btn').addEventListener('click', applyColor);
      document.querySelectorAll('.color-preset').forEach(preset => {
        preset.addEventListener('click', function() {
          document.getElementById('hoodieColor').value = this.dataset.color;
        });
      });

      // Add event listeners for decal size and rotation
      document.getElementById('decal-size').addEventListener('input', (e) => {
        currentDecalSize = parseFloat(e.target.value);
      });
      document.getElementById('decal-rotation').addEventListener('input', (e) => {
        currentDecalRotation = parseFloat(e.target.value);
      });

      // Add click event for placing decals
      window.addEventListener('click', onClick, false);

      // Load model
      loadModel();

      // Start animation loop
      animate();

      // Handle window resize
      window.addEventListener('resize', onWindowResize);
    }

    function onClick(event) {
      // Only place decals if we have an image uploaded
      if (!uploadedTexture || !hoodieModel) return;

      // Calculate mouse position in normalized device coordinates
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      // Update the raycaster
      raycaster.setFromCamera(mouse, camera);

      // Calculate objects intersecting the picking ray
      const intersects = raycaster.intersectObject(hoodieModel, true);
      
      if (intersects.length > 0) {
        const hit = intersects[0];
        placeDecalAt(hit.point, hit.face.normal, hit.object);
      }
    }

    function placeDecalAt(position, normal, targetMesh) {
      // Create orientation from the normal
      const orientation = new THREE.Euler().setFromQuaternion(
        new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, 1), normal)
      );
      
      // Apply additional rotation from the slider
      orientation.z += currentDecalRotation;
      
      const size = new THREE.Vector3(currentDecalSize, currentDecalSize, currentDecalSize);

      const decalMaterial = new THREE.MeshPhongMaterial({
        map: uploadedTexture,
        transparent: true,
        depthTest: true,
        depthWrite: false,
        polygonOffset: true,
        polygonOffsetFactor: -4,
        shininess: 30
      });

      const decalGeo = new DecalGeometry(targetMesh, position, orientation, size);
      const decalMesh = new THREE.Mesh(decalGeo, decalMaterial);
      decalMesh.userData = { size: currentDecalSize, rotation: currentDecalRotation };
      decalMesh.castShadow = true;
      scene.add(decalMesh);
      
      // Store reference to this decal
      decalMeshes.push(decalMesh);
    }

    function handleStickerUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        uploadedTexture = new THREE.TextureLoader().load(e.target.result, () => {
          // Show instructions
          document.getElementById('instructions').style.display = 'block';
          setTimeout(() => {
            document.getElementById('instructions').style.display = 'none';
          }, 3000);
        });
        uploadedTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
      };
      reader.readAsDataURL(file);
    }

    function applyColor() {
      const colorValue = document.getElementById('hoodieColor').value;
      if (hoodieModel) {
        hoodieModel.traverse(child => {
          if (child.isMesh && child.material) {
            if (Array.isArray(child.material)) {
              child.material.forEach(mat => {
                if (mat.isMeshStandardMaterial) {
                  mat.color.set(colorValue);
                }
              });
            } else if (child.material.isMeshStandardMaterial) {
              child.material.color.set(colorValue);
            }
          }
        });
      }
    }

    function toggleAnimation() {
      isAnimationPlaying = !isAnimationPlaying;
      
      if (currentAnimationAction) {
        if (isAnimationPlaying) {
          currentAnimationAction.play();
          document.getElementById('animation-toggle').textContent = 'Pause Animation';
        } else {
          currentAnimationAction.pause();
          document.getElementById('animation-toggle').textContent = 'Play Animation';
        }
      }
    }

    async function loadModel() {
      updateStatus('Loading hoodie model...');
      
      try {
        const loader = new GLTFLoader();
        const dracoLoader = new DRACOLoader();
        dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
        loader.setDRACOLoader(dracoLoader);
        
        const gltf = await loader.loadAsync('Hoodie_Walking_Animated.glb');
        hoodieModel = gltf.scene;
        scene.add(hoodieModel);

        // Enable shadows for all meshes
        hoodieModel.traverse(child => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
          }
        });

        // Setup animations if available
        if (gltf.animations && gltf.animations.length > 0) {
          mixer = new THREE.AnimationMixer(hoodieModel);
          currentAnimationAction = mixer.clipAction(gltf.animations[0]);
          currentAnimationAction.play();
          updateStatus('Model loaded with animation');
        } else {
          updateStatus('Model loaded');
          document.getElementById('animation-toggle').style.display = 'none';
        }

        // Center model
        const box = new THREE.Box3().setFromObject(hoodieModel);
        const center = box.getCenter(new THREE.Vector3());
        hoodieModel.position.sub(center);
        camera.position.z = box.getSize(new THREE.Vector3()).length() * 1.5;
        controls.update();

        // Hide loading overlay
        document.getElementById('loading-overlay').style.display = 'none';
      } catch (error) {
        updateStatus('Failed to load model');
        console.error(error);
        createFallbackModel();
        document.getElementById('animation-toggle').style.display = 'none';
      }
    }

    function createFallbackModel() {
      const geometry = new THREE.BoxGeometry(1, 1, 1);
      hoodieMaterial = new THREE.MeshStandardMaterial({ 
        color: new THREE.Color(document.getElementById('hoodieColor').value),
        roughness: 0.7,
        metalness: 0.1
      });
      hoodieModel = new THREE.Mesh(geometry, hoodieMaterial);
      scene.add(hoodieModel);
      
      document.getElementById('loading-overlay').style.display = 'none';
    }

    function updateStatus(msg) {
      document.getElementById('status').textContent = msg;
      console.log(msg);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      if (mixer && isAnimationPlaying) {
        mixer.update(delta);
      }
      controls.update();
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
