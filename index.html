<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Hoodie Viewer with Decals</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
    #viewer { width: 100vw; height: 100vh; }
    #controls {
      position: absolute; top: 10px; left: 10px; z-index: 100;
      background: rgba(255,255,255,0.8); padding: 10px; border-radius: 5px;
      max-height: 80vh; overflow-y: auto; width: 300px;
    }
    #loading-overlay {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.8); display: flex; flex-direction: column;
      justify-content: center; align-items: center; color: white; z-index: 100;
    }
    .spinner {
      width: 40px; height: 40px; border: 4px solid rgba(255,255,255,0.3);
      border-radius: 50%; border-top-color: #4361ee;
      animation: spin 1s ease-in-out infinite; margin-bottom: 15px;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    #status { margin-top: 10px; font-size: 1em; }
    .sticker-controls {
      border: 1px solid #ddd; padding: 10px; margin-top: 10px;
      border-radius: 5px; background: rgba(255,255,255,0.7);
    }
    .sticker-header {
      display: flex; justify-content: space-between;
      margin-bottom: 5px; font-weight: bold;
    }
    .remove-sticker {
      color: red; cursor: pointer;
    }
    #add-sticker-btn {
      margin-top: 10px; padding: 5px 10px;
      background: #4361ee; color: white;
      border: none; border-radius: 3px;
      cursor: pointer;
    }
    #animation-controls {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 100;
      background: rgba(255,255,255,0.8);
      padding: 10px;
      border-radius: 5px;
    }
    #animation-toggle {
      padding: 5px 10px;
      background: #4361ee;
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
    }
    #color-controls {
      position: absolute;
      top: 60px;
      right: 10px;
      z-index: 100;
      background: rgba(255,255,255,0.8);
      padding: 10px;
      border-radius: 5px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    #color-presets {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 5px;
    }
    .color-preset {
      width: 30px;
      height: 30px;
      border: 1px solid #ccc;
      cursor: pointer;
    }
    #apply-color-btn {
      padding: 5px 10px;
      background: #4361ee;
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
    }
    .size-controls {
      margin-top: 10px;
    }
    .size-controls input {
      width: 100%;
    }
  </style>
</head>
<body>
  <div id="controls">
    <div id="sticker-controls-container">
      <!-- Sticker controls will be added here dynamically -->
    </div>
    <button id="add-sticker-btn">Add New Decal</button>
  </div>
  
  <div id="animation-controls">
    <button id="animation-toggle">Pause Animation</button>
  </div>
  
  <div id="color-controls">
    <label for="hoodieColor">Hoodie Color:</label>
    <input type="color" id="hoodieColor" value="#4361ee">
    <div id="color-presets">
      <div class="color-preset" style="background-color: #4361ee;" data-color="#4361ee"></div>
      <div class="color-preset" style="background-color: #3a0ca3;" data-color="#3a0ca3"></div>
      <div class="color-preset" style="background-color: #7209b7;" data-color="#7209b7"></div>
      <div class="color-preset" style="background-color: #f72585;" data-color="#f72585"></div>
      <div class="color-preset" style="background-color: #4cc9f0;" data-color="#4cc9f0"></div>
      <div class="color-preset" style="background-color: #4895ef;" data-color="#4895ef"></div>
      <div class="color-preset" style="background-color: #3f37c9;" data-color="#3f37c9"></div>
      <div class="color-preset" style="background-color: #560bad;" data-color="#560bad"></div>
    </div>
    <button id="apply-color-btn">Apply Color</button>
  </div>
  
  <div id="loading-overlay">
    <div class="spinner"></div>
    <div id="status">Loading 3D Hoodie Viewer...</div>
  </div>
  <div id="viewer"></div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
    import { DecalGeometry } from 'three/addons/geometries/DecalGeometry.js';

    let scene, camera, renderer, controls, hoodieModel, mixer, clock;
    let hoodieMaterial;
    let decalMeshes = [];
    let isAnimationPlaying = true;
    let currentAnimationAction = null;

    init();

    function init() {
      // Setup scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf0f0f0);

      // Setup camera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 5;

      // Setup renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      document.getElementById('viewer').appendChild(renderer.domElement);

      // Lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(1, 1, 1);
      directionalLight.castShadow = true;
      scene.add(directionalLight);

      // Controls
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      // Clock for animations
      clock = new THREE.Clock();

      // Add event listener for adding new decals
      document.getElementById('add-sticker-btn').addEventListener('click', addNewDecalControl);

      // Add event listener for animation toggle
      document.getElementById('animation-toggle').addEventListener('click', toggleAnimation);

      // Add event listeners for color controls
      document.getElementById('apply-color-btn').addEventListener('click', applyColor);
      document.querySelectorAll('.color-preset').forEach(preset => {
        preset.addEventListener('click', function() {
          document.getElementById('hoodieColor').value = this.dataset.color;
        });
      });

      // Load model
      loadModel();

      // Start animation loop
      animate();

      // Handle window resize
      window.addEventListener('resize', onWindowResize);
    }

    function applyColor() {
      const colorValue = document.getElementById('hoodieColor').value;
      if (hoodieModel) {
        hoodieModel.traverse(child => {
          if (child.isMesh && child.material) {
            if (Array.isArray(child.material)) {
              child.material.forEach(mat => {
                if (mat.isMeshStandardMaterial) {
                  mat.color.set(colorValue);
                }
              });
            } else if (child.material.isMeshStandardMaterial) {
              child.material.color.set(colorValue);
            }
          }
        });
      }
    }

    function toggleAnimation() {
      isAnimationPlaying = !isAnimationPlaying;
      
      if (currentAnimationAction) {
        if (isAnimationPlaying) {
          currentAnimationAction.play();
          document.getElementById('animation-toggle').textContent = 'Pause Animation';
        } else {
          currentAnimationAction.pause();
          document.getElementById('animation-toggle').textContent = 'Play Animation';
        }
      }
    }

    async function loadModel() {
      updateStatus('Loading hoodie model...');
      
      try {
        const loader = new GLTFLoader();
        const dracoLoader = new DRACOLoader();
        dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
        loader.setDRACOLoader(dracoLoader);
        
        const gltf = await loader.loadAsync('Hoodie_Walking_Animated.glb');
        hoodieModel = gltf.scene;
        scene.add(hoodieModel);

        // Enable shadows for all meshes
        hoodieModel.traverse(child => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
          }
        });

        // Setup animations if available
        if (gltf.animations && gltf.animations.length > 0) {
          mixer = new THREE.AnimationMixer(hoodieModel);
          currentAnimationAction = mixer.clipAction(gltf.animations[0]);
          currentAnimationAction.play();
          updateStatus('Model loaded with animation');
        } else {
          updateStatus('Model loaded');
          document.getElementById('animation-toggle').style.display = 'none';
        }

        // Center model
        const box = new THREE.Box3().setFromObject(hoodieModel);
        const center = box.getCenter(new THREE.Vector3());
        hoodieModel.position.sub(center);
        camera.position.z = box.getSize(new THREE.Vector3()).length() * 1.5;
        controls.update();

        // Hide loading overlay
        document.getElementById('loading-overlay').style.display = 'none';
        
        // Add a default decal control to start with
        addNewDecalControl();
      } catch (error) {
        updateStatus('Failed to load model');
        console.error(error);
        createFallbackModel();
        document.getElementById('animation-toggle').style.display = 'none';
      }
    }

    function addNewDecalControl() {
      const decalId = 'decal-' + Date.now();
      const decalDiv = document.createElement('div');
      decalDiv.className = 'sticker-controls';
      decalDiv.id = decalId + '-controls';
      
      decalDiv.innerHTML = `
        <div class="sticker-header">
          <span>Decal ${decalMeshes.length + 1}</span>
          <span class="remove-sticker" data-id="${decalId}">×</span>
        </div>
        <input type="file" class="sticker-upload" accept="image/*" data-id="${decalId}">
        <div class="size-controls">
          <div>Size: <input type="range" class="decal-size" min="0.1" max="1" step="0.05" value="0.4" data-id="${decalId}"></div>
          <div>Rotation: <input type="range" class="decal-rotation" min="0" max="6.28" step="0.1" value="0" data-id="${decalId}"></div>
        </div>
      `;
      
      document.getElementById('sticker-controls-container').appendChild(decalDiv);
      
      // Add event listeners
      decalDiv.querySelector('.sticker-upload').addEventListener('change', (e) => handleDecalUpload(e, decalId));
      decalDiv.querySelector('.decal-size').addEventListener('input', (e) => updateDecalSize(e, decalId));
      decalDiv.querySelector('.decal-rotation').addEventListener('input', (e) => updateDecalRotation(e, decalId));
      decalDiv.querySelector('.remove-sticker').addEventListener('click', (e) => removeDecal(e, decalId));
    }

    function handleDecalUpload(event, decalId) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        const texture = new THREE.TextureLoader().load(e.target.result, () => {
          applyDecal(texture, decalId);
        });
        texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
      };
      reader.readAsDataURL(file);
    }

    function applyDecal(texture, decalId) {
      if (!hoodieModel) return;

      // Find the first suitable mesh to apply the decal to
      const targetMesh = hoodieModel.children.find(child => child.isMesh);
      if (!targetMesh) return;

      // Use the current camera target as decal position
      const position = controls.target.clone();
      
      // Add some offset to place it on the front of the hoodie
      position.add(new THREE.Vector3(0, 0.5, 0));
      
      // Get size from the control
      const sizeControl = document.querySelector(`.decal-size[data-id="${decalId}"]`);
      const sizeValue = sizeControl ? parseFloat(sizeControl.value) : 0.4;
      const size = new THREE.Vector3(sizeValue, sizeValue, sizeValue);
      
      // Get rotation from the control
      const rotationControl = document.querySelector(`.decal-rotation[data-id="${decalId}"]`);
      const rotationValue = rotationControl ? parseFloat(rotationControl.value) : 0;
      const orientation = new THREE.Euler(0, 0, rotationValue);

      const decalMaterial = new THREE.MeshPhongMaterial({
        map: texture,
        transparent: true,
        depthTest: true,
        depthWrite: false,
        polygonOffset: true,
        polygonOffsetFactor: -4,
        shininess: 30
      });

      const decalGeo = new DecalGeometry(targetMesh, position, orientation, size);
      const decalMesh = new THREE.Mesh(decalGeo, decalMaterial);
      decalMesh.userData.decalId = decalId;
      decalMesh.castShadow = true;
      scene.add(decalMesh);
      
      // Store reference to this decal
      decalMeshes.push(decalMesh);
    }

    function updateDecalSize(event, decalId) {
      const size = parseFloat(event.target.value);
      const decalMesh = decalMeshes.find(mesh => mesh.userData.decalId === decalId);
      if (decalMesh) {
        // To change size, we need to recreate the decal with new size
        const texture = decalMesh.material.map;
        removeDecalMesh(decalId);
        applyDecal(texture, decalId);
      }
    }

    function updateDecalRotation(event, decalId) {
      const rotation = parseFloat(event.target.value);
      const decalMesh = decalMeshes.find(mesh => mesh.userData.decalId === decalId);
      if (decalMesh) {
        // To change rotation, we need to recreate the decal with new rotation
        const texture = decalMesh.material.map;
        removeDecalMesh(decalId);
        applyDecal(texture, decalId);
      }
    }

    function removeDecal(event, decalId) {
      event.stopPropagation();
      removeDecalMesh(decalId);
      
      // Remove the controls div
      const element = document.getElementById(decalId + '-controls');
      if (element) element.remove();
    }

    function removeDecalMesh(decalId) {
      const index = decalMeshes.findIndex(mesh => mesh.userData.decalId === decalId);
      if (index !== -1) {
        const decalMesh = decalMeshes[index];
        scene.remove(decalMesh);
        if (decalMesh.geometry) decalMesh.geometry.dispose();
        if (decalMesh.material) decalMesh.material.dispose();
        decalMeshes.splice(index, 1);
      }
    }

    function createFallbackModel() {
      const geometry = new THREE.BoxGeometry(1, 1, 1);
      hoodieMaterial = new THREE.MeshStandardMaterial({ 
        color: new THREE.Color(document.getElementById('hoodieColor').value),
        roughness: 0.7,
        metalness: 0.1
      });
      hoodieModel = new THREE.Mesh(geometry, hoodieMaterial);
      scene.add(hoodieModel);
      
      document.getElementById('loading-overlay').style.display = 'none';
    }

    function updateStatus(msg) {
      document.getElementById('status').textContent = msg;
      console.log(msg);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      if (mixer && isAnimationPlaying) {
        mixer.update(delta);
      }
      controls.update();
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
