<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Hoodie Viewer with Advanced Controls</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
    #viewer { width: 100vw; height: 100vh; }
    #controls {
      position: absolute; top: 10px; left: 10px; z-index: 100;
      background: rgba(255,255,255,0.8); padding: 10px; border-radius: 5px;
      max-height: 80vh; overflow-y: auto; width: 300px;
    }
    #loading-overlay {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.8); display: flex; flex-direction: column;
      justify-content: center; align-items: center; color: white; z-index: 100;
    }
    .spinner {
      width: 40px; height: 40px; border: 4px solid rgba(255,255,255,0.3);
      border-radius: 50%; border-top-color: #4361ee;
      animation: spin 1s ease-in-out infinite; margin-bottom: 15px;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    #status { margin-top: 10px; font-size: 1em; }
    #uv-display {
      position: absolute; bottom: 10px; left: 10px; z-index: 100;
      background: rgba(255,255,255,0.8); padding: 10px; border-radius: 5px;
      font-family: monospace; font-size: 14px;
    }
    #uv-region-display {
      position: absolute; bottom: 10px; right: 10px; z-index: 100;
      background: rgba(255,255,255,0.8); padding: 10px; border-radius: 5px;
      width: 200px; height: 200px;
    }
    #uv-region-display canvas {
      width: 100%; height: 100%;
    }
    .sticker-controls {
      border: 1px solid #ddd; padding: 10px; margin-top: 10px;
      border-radius: 5px; background: rgba(255,255,255,0.7);
    }
    .sticker-header {
      display: flex; justify-content: space-between;
      margin-bottom: 5px; font-weight: bold;
    }
    .remove-sticker {
      color: red; cursor: pointer;
    }
    .active-sticker {
      background: rgba(67, 97, 238, 0.2);
    }
    #add-sticker-btn {
      margin-top: 10px; padding: 5px 10px;
      background: #4361ee; color: white;
      border: none; border-radius: 3px;
      cursor: pointer;
    }
    .position-presets {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      margin-top: 5px;
    }
    .position-preset-btn {
      padding: 3px 6px;
      background: #f0f0f0;
      border: 1px solid #ccc;
      border-radius: 3px;
      cursor: pointer;
      font-size: 12px;
    }
    .position-preset-btn:hover {
      background: #e0e0e0;
    }
    #animation-controls {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 100;
      background: rgba(255,255,255,0.8);
      padding: 10px;
      border-radius: 5px;
    }
    #animation-toggle {
      padding: 5px 10px;
      background: #4361ee;
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
    }
    #color-controls {
      position: absolute;
      top: 60px;
      right: 10px;
      z-index: 100;
      background: rgba(255,255,255,0.8);
      padding: 10px;
      border-radius: 5px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    #color-presets {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 5px;
    }
    .color-preset {
      width: 30px;
      height: 30px;
      border: 1px solid #ccc;
      cursor: pointer;
    }
    #apply-color-btn {
      padding: 5px 10px;
      background: #4361ee;
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
    }
    #environment-controls {
      position: absolute;
      top: 220px;
      right: 10px;
      z-index: 100;
      background: rgba(255,255,255,0.8);
      padding: 10px;
      border-radius: 5px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      width: 200px;
    }
    .control-group {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    .control-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    select, input[type="range"] {
      width: 100%;
    }
    #material-effects {
      position: absolute;
      top: 450px;
      right: 10px;
      z-index: 100;
      background: rgba(255,255,255,0.8);
      padding: 10px;
      border-radius: 5px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      width: 200px;
    }
  </style>
</head>
<body>
  <div id="controls">
    <div id="sticker-controls-container">
      <!-- Sticker controls will be added here dynamically -->
    </div>
    <button id="add-sticker-btn">Add New Sticker</button>
  </div>
  
  <div id="animation-controls">
    <button id="animation-toggle">Pause Animation</button>
  </div>
  
  <div id="color-controls">
    <label for="hoodieColor">Hoodie Color:</label>
    <input type="color" id="hoodieColor" value="#4361ee">
    <div id="color-presets">
      <div class="color-preset" style="background-color: #4361ee;" data-color="#4361ee"></div>
      <div class="color-preset" style="background-color: #3a0ca3;" data-color="#3a0ca3"></div>
      <div class="color-preset" style="background-color: #7209b7;" data-color="#7209b7"></div>
      <div class="color-preset" style="background-color: #f72585;" data-color="#f72585"></div>
      <div class="color-preset" style="background-color: #4cc9f0;" data-color="#4cc9f0"></div>
      <div class="color-preset" style="background-color: #4895ef;" data-color="#4895ef"></div>
      <div class="color-preset" style="background-color: #3f37c9;" data-color="#3f37c9"></div>
      <div class="color-preset" style="background-color: #560bad;" data-color="#560bad"></div>
    </div>
    <button id="apply-color-btn">Apply Color</button>
  </div>
  
  <div id="environment-controls">
    <div class="control-group">
      <label for="environment-select">Environment:</label>
      <select id="environment-select">
        <option value="neutral">Neutral</option>
        <option value="venice">Venice Sunset</option>
        <option value="none">None</option>
      </select>
    </div>
    <div class="control-group">
      <label for="tone-mapping">Tone Mapping:</label>
      <select id="tone-mapping">
        <option value="aces">ACES Filmic</option>
        <option value="linear">Linear</option>
      </select>
    </div>
    <div class="control-group">
      <div class="control-row">
        <label for="exposure">Exposure:</label>
        <span id="exposure-value">1.0</span>
      </div>
      <input type="range" id="exposure" min="0" max="2" step="0.1" value="1">
    </div>
    <div class="control-group">
      <div class="control-row">
        <label for="ambient-intensity">Ambient Intensity:</label>
        <span id="ambient-intensity-value">0.5</span>
      </div>
      <input type="range" id="ambient-intensity" min="0" max="1" step="0.05" value="0.5">
    </div>
    <div class="control-group">
      <div class="control-row">
        <label for="direct-intensity">Direct Intensity:</label>
        <span id="direct-intensity-value">1.0</span>
      </div>
      <input type="range" id="direct-intensity" min="0" max="2" step="0.1" value="1.0">
    </div>
  </div>
  
  <div id="material-effects">
    <div class="control-group">
      <label for="material-type">Material Effect:</label>
      <select id="material-type">
        <option value="default">Default</option>
        <option value="wool">Wool</option>
        <option value="leather">Leather</option>
        <option value="polymer">Polymer</option>
      </select>
    </div>
    <div class="control-group">
      <div class="control-row">
        <label for="roughness">Roughness:</label>
        <span id="roughness-value">0.7</span>
      </div>
      <input type="range" id="roughness" min="0" max="1" step="0.05" value="0.7">
    </div>
    <div class="control-group">
      <div class="control-row">
        <label for="metalness">Metalness:</label>
        <span id="metalness-value">0.1</span>
      </div>
      <input type="range" id="metalness" min="0" max="1" step="0.05" value="0.1">
    </div>
  </div>
  
  <div id="uv-display">
    Current UV: (0.0, 0.0)<br>
    Scale: 0.5<br>
    Rotation: 0.0
  </div>
  
  <div id="uv-region-display">
    <canvas id="uv-region-canvas"></canvas>
    <div>Front Main Region</div>
  </div>
  
  <div id="loading-overlay">
    <div class="spinner"></div>
    <div id="status">Loading 3D Hoodie Viewer...</div>
  </div>
  <div id="viewer"></div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
    import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
    import { PMREMGenerator } from 'three/addons/pmrem/PMREMGenerator.js';

    let scene, camera, renderer, controls, hoodieModel, mixer, clock;
    let decalMaterial, baseTexture, hoodieMaterial, envMap, pmremGenerator;
    let uvRegionCanvas, uvRegionCtx;
    const uvRegions = [{
      id: 'front',         // Internal identifier (must be unique)
      name: 'Front Main',  // Display name shown in UI
      u: 0.5,             // Horizontal center position (0-1)
      v: 0.5,             // Vertical center position (0-1)
      width: 0.3,         // Width of the region (0-1)
      height: 0.4         // Height of the region (0-1)
    }];

    // Updated position presets with absolute UV coordinates
    const positionPresets = [
      { 
        name: "Back", 
        uv: { u: 0.83, v: -0.36 }, // Absolute UV coordinates
        scale: 0.30,
        rotation: 3.20
      },
      { 
        name: "Front", 
        uv: { u: -0.42, v: -0.36 },
        scale: 0.30,
        rotation: 3.20
      },
      { 
        name: "Left Arm", 
        uv: { u: 0.44, v: 1.50 },
        scale: 0.25,
        rotation: 2.90
      },
      { 
        name: "Right Arm", 
        uv: { u: -0.50, v: 1.50 },
        scale: 0.35,
        rotation: 3.00
      },
      { 
        name: "Hood", 
        uv: { u: 1.50, v: 0.85 },
        scale: 0.20,
        rotation: 3.30
      }
    ];

    // Array to store all stickers
    let stickers = [];
    let activeStickerIndex = 0;
    const MAX_DECALS = 10; // Maximum number of decals we support
    let isAnimationPlaying = true;
    let currentAnimationAction = null;
    let directionalLight, ambientLight;

    init();

    function init() {
      // Setup scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf0f0f0);

      // Setup camera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 5;

      // Setup renderer with tone mapping
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.0;
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.getElementById('viewer').appendChild(renderer.domElement);

      // Lights
      ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      
      directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(1, 1, 1);
      scene.add(directionalLight);

      // Controls
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      // Clock for animations
      clock = new THREE.Clock();

      // Setup PMREM generator for environment maps
      pmremGenerator = new PMREMGenerator(renderer);
      pmremGenerator.compileEquirectangularShader();

      // Setup UV region display
      uvRegionCanvas = document.getElementById('uv-region-canvas');
      uvRegionCanvas.width = 200;
      uvRegionCanvas.height = 200;
      uvRegionCtx = uvRegionCanvas.getContext('2d');
      drawUVRegion();

      // Add event listeners
      setupEventListeners();

      // Load model
      loadModel();

      // Start animation loop
      animate();

      // Handle window resize
      window.addEventListener('resize', onWindowResize);
    }

    function setupEventListeners() {
      // Sticker controls
      document.getElementById('add-sticker-btn').addEventListener('click', addNewSticker);
      document.getElementById('animation-toggle').addEventListener('click', toggleAnimation);

      // Color controls
      document.getElementById('apply-color-btn').addEventListener('click', applyColor);
      document.querySelectorAll('.color-preset').forEach(preset => {
        preset.addEventListener('click', function() {
          document.getElementById('hoodieColor').value = this.dataset.color;
        });
      });

      // Environment controls
      document.getElementById('environment-select').addEventListener('change', updateEnvironment);
      document.getElementById('tone-mapping').addEventListener('change', updateToneMapping);
      document.getElementById('exposure').addEventListener('input', updateExposure);
      document.getElementById('ambient-intensity').addEventListener('input', updateAmbientLight);
      document.getElementById('direct-intensity').addEventListener('input', updateDirectLight);

      // Material effects
      document.getElementById('material-type').addEventListener('change', updateMaterialEffect);
      document.getElementById('roughness').addEventListener('input', updateMaterialProperties);
      document.getElementById('metalness').addEventListener('input', updateMaterialProperties);
    }

    function updateEnvironment() {
      const envType = document.getElementById('environment-select').value;
      
      if (envType === 'none') {
        scene.environment = null;
        return;
      }
      
      const path = envType === 'venice' ? 
        'https://cdn.jsdelivr.net/gh/mrdoob/three.js@dev/examples/textures/equirectangular/venice_sunset_1k.hdr' :
        'https://cdn.jsdelivr.net/gh/mrdoob/three.js@dev/examples/textures/equirectangular/neutral.hdr';
      
      new RGBELoader()
        .load(path, (texture) => {
          envMap = pmremGenerator.fromEquirectangular(texture).texture;
          scene.environment = envMap;
          texture.dispose();
          
          if (hoodieMaterial) {
            hoodieMaterial.envMap = envMap;
            hoodieMaterial.needsUpdate = true;
          }
        });
    }

    function updateToneMapping() {
      const mapping = document.getElementById('tone-mapping').value;
      renderer.toneMapping = mapping === 'aces' ? THREE.ACESFilmicToneMapping : THREE.LinearToneMapping;
    }

    function updateExposure() {
      const value = parseFloat(document.getElementById('exposure').value);
      renderer.toneMappingExposure = value;
      document.getElementById('exposure-value').textContent = value.toFixed(1);
    }

    function updateAmbientLight() {
      const value = parseFloat(document.getElementById('ambient-intensity').value);
      ambientLight.intensity = value;
      document.getElementById('ambient-intensity-value').textContent = value.toFixed(2);
    }

    function updateDirectLight() {
      const value = parseFloat(document.getElementById('direct-intensity').value);
      directionalLight.intensity = value;
      document.getElementById('direct-intensity-value').textContent = value.toFixed(1);
    }

    function updateMaterialEffect() {
      const effect = document.getElementById('material-type').value;
      if (!hoodieMaterial) return;
      
      switch(effect) {
        case 'wool':
          hoodieMaterial.roughness = 0.9;
          hoodieMaterial.metalness = 0.0;
          break;
        case 'leather':
          hoodieMaterial.roughness = 0.5;
          hoodieMaterial.metalness = 0.1;
          break;
        case 'polymer':
          hoodieMaterial.roughness = 0.3;
          hoodieMaterial.metalness = 0.8;
          break;
        default:
          hoodieMaterial.roughness = 0.7;
          hoodieMaterial.metalness = 0.1;
      }
      
      // Update sliders to match new values
      document.getElementById('roughness').value = hoodieMaterial.roughness;
      document.getElementById('metalness').value = hoodieMaterial.metalness;
      document.getElementById('roughness-value').textContent = hoodieMaterial.roughness.toFixed(2);
      document.getElementById('metalness-value').textContent = hoodieMaterial.metalness.toFixed(2);
      
      hoodieMaterial.needsUpdate = true;
    }

    function updateMaterialProperties() {
      if (!hoodieMaterial) return;
      
      hoodieMaterial.roughness = parseFloat(document.getElementById('roughness').value);
      hoodieMaterial.metalness = parseFloat(document.getElementById('metalness').value);
      
      document.getElementById('roughness-value').textContent = hoodieMaterial.roughness.toFixed(2);
      document.getElementById('metalness-value').textContent = hoodieMaterial.metalness.toFixed(2);
      
      hoodieMaterial.needsUpdate = true;
    }

    function applyColor() {
      const colorValue = document.getElementById('hoodieColor').value;
      if (hoodieMaterial) {
        hoodieMaterial.color.set(colorValue);
        hoodieMaterial.needsUpdate = true;
      }
    }

    function toggleAnimation() {
      isAnimationPlaying = !isAnimationPlaying;
      
      if (currentAnimationAction) {
        if (isAnimationPlaying) {
          currentAnimationAction.play();
          document.getElementById('animation-toggle').textContent = 'Pause Animation';
        } else {
          currentAnimationAction.pause();
          document.getElementById('animation-toggle').textContent = 'Play Animation';
        }
      }
    }

    function drawUVRegion() {
      const region = uvRegions[0];
      const canvasSize = 200;
      const padding = 10;
      
      // Clear canvas
      uvRegionCtx.clearRect(0, 0, canvasSize, canvasSize);
      
      // Draw background
      uvRegionCtx.fillStyle = '#ffffff';
      uvRegionCtx.fillRect(0, 0, canvasSize, canvasSize);
      
      // Draw region outline
      uvRegionCtx.strokeStyle = '#4361ee';
      uvRegionCtx.lineWidth = 2;
      uvRegionCtx.beginPath();
      uvRegionCtx.rect(
        padding + (region.u - region.width/2) * (canvasSize - 2*padding),
        padding + (1 - region.v - region.height/2) * (canvasSize - 2*padding),
        region.width * (canvasSize - 2*padding),
        region.height * (canvasSize - 2*padding)
      );
      uvRegionCtx.stroke();
      
      // Draw center point
      uvRegionCtx.fillStyle = '#ff0000';
      uvRegionCtx.beginPath();
      uvRegionCtx.arc(
        padding + region.u * (canvasSize - 2*padding),
        padding + (1 - region.v) * (canvasSize - 2*padding),
        3, 0, Math.PI * 2
      );
      uvRegionCtx.fill();
      
      // Draw all sticker positions
      stickers.forEach((sticker, index) => {
        const posX = sticker.position.x;
        const posY = sticker.position.y;
        const isActive = index === activeStickerIndex;
        
        uvRegionCtx.fillStyle = isActive ? '#00ff00' : '#4361ee';
        uvRegionCtx.beginPath();
        uvRegionCtx.arc(
          padding + (region.u + posX) * (canvasSize - 2*padding),
          padding + (1 - region.v - posY) * (canvasSize - 2*padding),
          5, 0, Math.PI * 2
        );
        uvRegionCtx.fill();
        
        // Draw scale indicator
        const scale = sticker.scale * 20;
        uvRegionCtx.strokeStyle = isActive ? '#00ff00' : '#4361ee';
        uvRegionCtx.beginPath();
        uvRegionCtx.arc(
          padding + (region.u + posX) * (canvasSize - 2*padding),
          padding + (1 - region.v - posY) * (canvasSize - 2*padding),
          scale, 0, Math.PI * 2
        );
        uvRegionCtx.stroke();
      });
      
      // Update UV display for active sticker
      if (stickers.length > 0) {
        const activeSticker = stickers[activeStickerIndex];
        updateUVDisplay(
          activeSticker.position.x, 
          activeSticker.position.y,
          activeSticker.scale,
          activeSticker.rotation
        );
      }
    }

    function updateUVDisplay(u, v, scale, rotation) {
      document.getElementById('uv-display').innerHTML = 
        `Current UV: (${u.toFixed(2)}, ${v.toFixed(2)})<br>
         Scale: ${scale.toFixed(2)}<br>
         Rotation: ${rotation.toFixed(2)}`;
    }

    async function loadModel() {
      updateStatus('Loading hoodie model...');
      
      try {
        const loader = new GLTFLoader();
        const dracoLoader = new DRACOLoader();
        dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
        loader.setDRACOLoader(dracoLoader);
        
        const gltf = await loader.loadAsync('Hoodie_Walking_Animated.glb');
        hoodieModel = gltf.scene;
        scene.add(hoodieModel);

        // Setup animations if available
        if (gltf.animations && gltf.animations.length > 0) {
          mixer = new THREE.AnimationMixer(hoodieModel);
          currentAnimationAction = mixer.clipAction(gltf.animations[0]);
          currentAnimationAction.play();
          updateStatus('Model loaded with animation');
        } else {
          updateStatus('Model loaded');
          document.getElementById('animation-toggle').style.display = 'none';
        }

        // Create a default white texture
        baseTexture = createDefaultTexture();
        
        // Create base material for the hoodie
        hoodieMaterial = new THREE.MeshStandardMaterial({
          color: new THREE.Color(document.getElementById('hoodieColor').value),
          roughness: parseFloat(document.getElementById('roughness').value),
          metalness: parseFloat(document.getElementById('metalness').value),
          envMap: scene.environment
        });
        
        // Create decal material
        decalMaterial = createDecalMaterial(baseTexture, hoodieMaterial);
        
        // Apply materials to all meshes
        hoodieModel.traverse((child) => {
          if (child.isMesh) {
            // Store the original material
            child.userData.originalMaterial = child.material;
            // Apply our custom material
            child.material = decalMaterial;
          }
        });

        // Center model
        const box = new THREE.Box3().setFromObject(hoodieModel);
        const center = box.getCenter(new THREE.Vector3());
        hoodieModel.position.sub(center);
        camera.position.z = box.getSize(new THREE.Vector3()).length() * 1.5;
        controls.update();

        // Load default environment
        updateEnvironment();

        // Hide loading overlay
        document.getElementById('loading-overlay').style.display = 'none';
        
        // Add a default sticker to start with
        addNewSticker();
      } catch (error) {
        updateStatus('Failed to load model');
        console.error(error);
        createFallbackModel();
        document.getElementById('animation-toggle').style.display = 'none';
      }
    }

    function createDefaultTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = canvas.height = 2;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = '#4361ee';
      ctx.fillRect(0, 0, 2, 2);
      return new THREE.CanvasTexture(canvas);
    }

    function createDecalMaterial(baseTexture, baseMaterial) {
      // Create uniforms object
      const uniforms = {
        baseTexture: { value: baseTexture },
        baseColor: { value: baseMaterial.color },
        decalCount: { value: 0 }
      };

      // Add texture slots for up to MAX_DECALS decals
      for (let i = 0; i < MAX_DECALS; i++) {
        uniforms[`decalTexture${i}`] = { value: null };
        uniforms[`decalPosition${i}`] = { value: new THREE.Vector2(0, 0) };
        uniforms[`decalScale${i}`] = { value: 1.0 };
        uniforms[`decalRotation${i}`] = { value: 0.0 };
      }

      // Generate the fragment shader dynamically based on MAX_DECALS
      let fragmentShader = `
        uniform sampler2D baseTexture;
        uniform vec3 baseColor;
        uniform int decalCount;
        varying vec2 vUV;
        
        // Declare all decal uniforms
      `;

      // Add uniform declarations
      for (let i = 0; i < MAX_DECALS; i++) {
        fragmentShader += `
          uniform sampler2D decalTexture${i};
          uniform vec2 decalPosition${i};
          uniform float decalScale${i};
          uniform float decalRotation${i};
        `;
      }

      fragmentShader += `
        void main() {
          vec4 baseTexColor = texture2D(baseTexture, vUV);
          vec4 baseColorWithAlpha = vec4(baseColor, 1.0);
          vec4 finalColor = mix(baseTexColor, baseColorWithAlpha, 0.5);
          
          // Apply decals in order
      `;

      // Add decal application logic
      for (let i = 0; i < MAX_DECALS; i++) {
        fragmentShader += `
          if (decalCount > ${i}) {
            vec2 center = vec2(0.5);
            vec2 uv = vUV - center;
            
            // Apply rotation
            float cosRot = cos(decalRotation${i});
            float sinRot = sin(decalRotation${i});
            uv = vec2(
              uv.x * cosRot - uv.y * sinRot,
              uv.x * sinRot + uv.y * cosRot
            );
            
            // Apply scale and position
            uv = uv / decalScale${i} + decalPosition${i} + center;
            
            if (uv.x >= 0.0 && uv.x <= 1.0 && uv.y >= 0.0 && uv.y <= 1.0) {
              vec4 decalColor = texture2D(decalTexture${i}, uv);
              finalColor = mix(finalColor, decalColor, decalColor.a);
            }
          }
        `;
      }

      fragmentShader += `
          gl_FragColor = finalColor;
        }
      `;

      const vertexShader = `
        varying vec2 vUV;
        void main() {
          vUV = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `;

      return new THREE.ShaderMaterial({
        uniforms: uniforms,
        vertexShader: vertexShader,
        fragmentShader: fragmentShader,
        transparent: true
      });
    }

    function addNewSticker() {
      if (stickers.length >= MAX_DECALS) {
        alert(`Maximum number of stickers (${MAX_DECALS}) reached`);
        return;
      }

      const stickerId = 'sticker-' + Date.now();
      const newSticker = {
        id: stickerId,
        texture: null,
        position: new THREE.Vector2(0, 0),
        scale: 0.5,
        rotation: 0,
        element: null,
        index: stickers.length
      };
      
      stickers.push(newSticker);
      activeStickerIndex = stickers.length - 1;
      
      createStickerControls(newSticker);
      updateDecalUniforms();
      drawUVRegion();
    }

    function createStickerControls(sticker) {
      const container = document.getElementById('sticker-controls-container');
      
      const stickerDiv = document.createElement('div');
      stickerDiv.className = 'sticker-controls';
      stickerDiv.id = sticker.id + '-controls';
      if (stickers.length - 1 === activeStickerIndex) {
        stickerDiv.classList.add('active-sticker');
      }
      
      stickerDiv.innerHTML = `
        <div class="sticker-header">
          <span>Sticker ${sticker.index + 1}</span>
          <span class="remove-sticker" data-id="${sticker.id}">×</span>
        </div>
        <input type="file" class="sticker-upload" accept="image/*" data-id="${sticker.id}">
        <div>Position: <input type="range" class="position-x" min="-2" max="2" step="0.01" value="0" data-id="${sticker.id}"> X</div>
        <div><input type="range" class="position-y" min="-2" max="2" step="0.01" value="0" data-id="${sticker.id}"> Y</div>
        <div>Scale: <input type="range" class="scale" min="0.1" max="2" step="0.05" value="0.5" data-id="${sticker.id}"></div>
        <div>Rotation: <input type="range" class="rotation" min="0" max="6.28" step="0.1" value="0" data-id="${sticker.id}"></div>
        <div class="position-presets">
          ${positionPresets.map(preset => 
            `<button class="position-preset-btn" 
              data-u="${preset.uv.u}" 
              data-v="${preset.uv.v}"
              data-scale="${preset.scale}"
              data-rotation="${preset.rotation}">${preset.name}</button>`
          ).join('')}
        </div>
      `;
      
      container.appendChild(stickerDiv);
      sticker.element = stickerDiv;
      
      // Add event listeners
      stickerDiv.querySelector('.sticker-upload').addEventListener('change', (e) => handleStickerUpload(e, sticker.id));
      stickerDiv.querySelector('.position-x').addEventListener('input', (e) => updateStickerPosition(e, sticker.id, 'x'));
      stickerDiv.querySelector('.position-y').addEventListener('input', (e) => updateStickerPosition(e, sticker.id, 'y'));
      stickerDiv.querySelector('.scale').addEventListener('input', (e) => updateStickerScale(e, sticker.id));
      stickerDiv.querySelector('.rotation').addEventListener('input', (e) => updateStickerRotation(e, sticker.id));
      stickerDiv.querySelector('.remove-sticker').addEventListener('click', (e) => removeSticker(e, sticker.id));
      
      // Add event listeners for position preset buttons
      stickerDiv.querySelectorAll('.position-preset-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const u = parseFloat(e.target.dataset.u);
          const v = parseFloat(e.target.dataset.v);
          const scale = parseFloat(e.target.dataset.scale);
          const rotation = parseFloat(e.target.dataset.rotation);
          applyPositionPreset(sticker.id, u, v, scale, rotation);
        });
      });
      
      // Make sticker active when clicked
      stickerDiv.addEventListener('click', () => {
        setActiveSticker(sticker.id);
      });
    }

    function applyPositionPreset(stickerId, u, v, scale, rotation) {
      const stickerIndex = stickers.findIndex(s => s.id === stickerId);
      if (stickerIndex !== -1) {
        stickers[stickerIndex].position.set(u, v);
        stickers[stickerIndex].scale = scale;
        stickers[stickerIndex].rotation = rotation;
        
        // Update the slider controls to reflect the new values
        const stickerDiv = document.getElementById(stickerId + '-controls');
        if (stickerDiv) {
          stickerDiv.querySelector('.position-x').value = u;
          stickerDiv.querySelector('.position-y').value = v;
          stickerDiv.querySelector('.scale').value = scale;
          stickerDiv.querySelector('.rotation').value = rotation;
        }
        
        updateDecalUniforms();
        drawUVRegion();
      }
    }

    function setActiveSticker(stickerId) {
      const index = stickers.findIndex(s => s.id === stickerId);
      if (index !== -1) {
        activeStickerIndex = index;
        
        // Update UI to show active sticker
        document.querySelectorAll('.sticker-controls').forEach(div => {
          div.classList.remove('active-sticker');
        });
        document.getElementById(stickerId + '-controls').classList.add('active-sticker');
        
        drawUVRegion();
      }
    }

    function handleStickerUpload(event, stickerId) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {
          const texture = new THREE.Texture(img);
          texture.needsUpdate = true;
          
          const stickerIndex = stickers.findIndex(s => s.id === stickerId);
          if (stickerIndex !== -1) {
            stickers[stickerIndex].texture = texture;
            updateDecalUniforms();
          }
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    }

    function updateStickerPosition(event, stickerId, axis) {
      const value = parseFloat(event.target.value);
      const stickerIndex = stickers.findIndex(s => s.id === stickerId);
      
      if (stickerIndex !== -1) {
        if (axis === 'x') {
          stickers[stickerIndex].position.x = value;
        } else {
          stickers[stickerIndex].position.y = value;
        }
        
        updateDecalUniforms();
        drawUVRegion();
      }
    }

    function updateStickerScale(event, stickerId) {
      const value = parseFloat(event.target.value);
      const stickerIndex = stickers.findIndex(s => s.id === stickerId);
      
      if (stickerIndex !== -1) {
        stickers[stickerIndex].scale = value;
        updateDecalUniforms();
        drawUVRegion();
      }
    }

    function updateStickerRotation(event, stickerId) {
      const value = parseFloat(event.target.value);
      const stickerIndex = stickers.findIndex(s => s.id === stickerId);
      
      if (stickerIndex !== -1) {
        stickers[stickerIndex].rotation = value;
        updateDecalUniforms();
        drawUVRegion();
      }
    }

    function removeSticker(event, stickerId) {
      event.stopPropagation();
      
      const stickerIndex = stickers.findIndex(s => s.id === stickerId);
      if (stickerIndex !== -1) {
        // Remove from DOM
        const element = document.getElementById(stickerId + '-controls');
        if (element) element.remove();
        
        // Remove from array
        stickers.splice(stickerIndex, 1);
        
        // Update indices of remaining stickers
        stickers.forEach((sticker, index) => {
          sticker.index = index;
          if (sticker.element) {
            sticker.element.querySelector('.sticker-header span:first-child').textContent = `Sticker ${index + 1}`;
          }
        });
        
        // Update active sticker index if needed
        if (activeStickerIndex >= stickerIndex) {
          activeStickerIndex = Math.max(0, activeStickerIndex - 1);
        }
        
        // Update the material
        updateDecalUniforms();
        drawUVRegion();
      }
    }

    function updateDecalUniforms() {
      if (!decalMaterial) return;
      
      decalMaterial.uniforms.decalCount.value = stickers.length;
      decalMaterial.uniforms.baseColor.value = hoodieMaterial.color;
      
      // Reset all uniforms first
      for (let i = 0; i < MAX_DECALS; i++) {
        decalMaterial.uniforms[`decalTexture${i}`].value = null;
        decalMaterial.uniforms[`decalPosition${i}`].value.set(0, 0);
        decalMaterial.uniforms[`decalScale${i}`].value = 1.0;
        decalMaterial.uniforms[`decalRotation${i}`].value = 0.0;
      }
      
      // Update active stickers
      stickers.forEach((sticker, index) => {
        decalMaterial.uniforms[`decalTexture${index}`].value = sticker.texture || createDefaultTexture();
        decalMaterial.uniforms[`decalPosition${index}`].value.copy(sticker.position);
        decalMaterial.uniforms[`decalScale${index}`].value = sticker.scale;
        decalMaterial.uniforms[`decalRotation${index}`].value = sticker.rotation;
      });
      
      decalMaterial.needsUpdate = true;
    }

    function createFallbackModel() {
      const geometry = new THREE.BoxGeometry(1, 1, 1);
      hoodieMaterial = new THREE.MeshStandardMaterial({ 
        color: new THREE.Color(document.getElementById('hoodieColor').value),
        roughness: parseFloat(document.getElementById('roughness').value),
        metalness: parseFloat(document.getElementById('metalness').value),
        envMap: scene.environment
      });
      hoodieModel = new THREE.Mesh(geometry, hoodieMaterial);
      scene.add(hoodieModel);
      
      document.getElementById('loading-overlay').style.display = 'none';
    }

    function updateStatus(msg) {
      document.getElementById('status').textContent = msg;
      console.log(msg);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      if (mixer && isAnimationPlaying) {
        mixer.update(delta);
      }
      controls.update();
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
