<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Hoodie Viewer with Sticker</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
    #viewer { width: 100vw; height: 100vh; }
    #controls {
      position: absolute; top: 10px; left: 10px; z-index: 100;
      background: rgba(255,255,255,0.8); padding: 10px; border-radius: 5px;
    }
    #loading-overlay {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.8); display: flex; flex-direction: column;
      justify-content: center; align-items: center; color: white; z-index: 100;
    }
    .spinner {
      width: 40px; height: 40px; border: 4px solid rgba(255,255,255,0.3);
      border-radius: 50%; border-top-color: #4361ee;
      animation: spin 1s ease-in-out infinite; margin-bottom: 15px;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    #status { margin-top: 10px; font-size: 1em; }
  </style>
</head>
<body>
  <div id="controls">
    <input type="file" id="sticker-upload" accept="image/*">
    <div>Position: <input type="range" id="position-x" min="-1" max="1" step="0.01" value="0"> X</div>
    <div><input type="range" id="position-y" min="-1" max="1" step="0.01" value="0"> Y</div>
    <div>Scale: <input type="range" id="scale" min="0.1" max="2" step="0.05" value="0.5"></div>
  </div>
  
  <div id="loading-overlay">
    <div class="spinner"></div>
    <div id="status">Loading 3D Hoodie Viewer...</div>
  </div>
  <div id="viewer"></div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';

    let scene, camera, renderer, controls, hoodieModel, mixer, clock;
    let decalMaterial, currentStickerTexture = null;

    init();

    function init() {
      // Setup scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf0f0f0);

      // Setup camera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 5;

      // Setup renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.getElementById('viewer').appendChild(renderer.domElement);

      // Lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(1, 1, 1);
      scene.add(directionalLight);

      // Controls
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      // Clock for animations
      clock = new THREE.Clock();

      // UI Event Listeners
      document.getElementById('sticker-upload').addEventListener('change', handleStickerUpload);
      document.getElementById('position-x').addEventListener('input', updateDecal);
      document.getElementById('position-y').addEventListener('input', updateDecal);
      document.getElementById('scale').addEventListener('input', updateDecal);

      // Load model
      loadModel();

      // Start animation loop
      animate();

      // Handle window resize
      window.addEventListener('resize', onWindowResize);
    }

    async function loadModel() {
      updateStatus('Loading hoodie model...');
      
      try {
        const loader = new GLTFLoader();
        const dracoLoader = new DRACOLoader();
        dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
        loader.setDRACOLoader(dracoLoader);
        
        const gltf = await loader.loadAsync('Hoodie_Walking_Animated.glb');
        hoodieModel = gltf.scene;
        scene.add(hoodieModel);

        // Setup animations if available
        if (gltf.animations && gltf.animations.length > 0) {
          mixer = new THREE.AnimationMixer(hoodieModel);
          mixer.clipAction(gltf.animations[0]).play();
          updateStatus('Model loaded with animation');
        } else {
          updateStatus('Model loaded');
        }

        // Create a default white texture
        const defaultTexture = createDefaultTexture();
        
        // Create decal material
        decalMaterial = createDecalMaterial(defaultTexture);
        
        // Apply material to all meshes
        hoodieModel.traverse((child) => {
          if (child.isMesh) {
            child.material = decalMaterial;
          }
        });

        // Center model
        const box = new THREE.Box3().setFromObject(hoodieModel);
        const center = box.getCenter(new THREE.Vector3());
        hoodieModel.position.sub(center);
        camera.position.z = box.getSize(new THREE.Vector3()).length() * 1.5;
        controls.update();

        // Hide loading overlay
        document.getElementById('loading-overlay').style.display = 'none';
      } catch (error) {
        updateStatus('Failed to load model');
        console.error(error);
        createFallbackModel();
      }
    }

    function createDefaultTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = canvas.height = 2;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = '#4361ee';
      ctx.fillRect(0, 0, 2, 2);
      return new THREE.CanvasTexture(canvas);
    }

    function createDecalMaterial(baseTexture) {
      return new THREE.ShaderMaterial({
        uniforms: {
          baseTexture: { value: baseTexture },
          decalTexture: { value: null },
          decalPosition: { value: new THREE.Vector2(0, 0) },
          decalScale: { value: 0.5 },
          decalRotation: { value: 0 },
          useDecal: { value: false }
        },
        vertexShader: `
          varying vec2 vUV;
          void main() {
            vUV = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform sampler2D baseTexture;
          uniform sampler2D decalTexture;
          uniform vec2 decalPosition;
          uniform float decalScale;
          uniform float decalRotation;
          uniform bool useDecal;
          varying vec2 vUV;

          void main() {
            vec4 baseColor = texture2D(baseTexture, vUV);
            
            if (useDecal) {
              vec2 center = vec2(0.5);
              vec2 uv = vUV - center;
              
              // Apply rotation
              float cosRot = cos(decalRotation);
              float sinRot = sin(decalRotation);
              uv = vec2(
                uv.x * cosRot - uv.y * sinRot,
                uv.x * sinRot + uv.y * cosRot
              );
              
              // Apply scale and position
              uv = uv / decalScale + decalPosition + center;
              
              if (uv.x >= 0.0 && uv.x <= 1.0 && uv.y >= 0.0 && uv.y <= 1.0) {
                vec4 decalColor = texture2D(decalTexture, uv);
                baseColor = mix(baseColor, decalColor, decalColor.a);
              }
            }
            
            gl_FragColor = baseColor;
          }
        `,
        transparent: true
      });
    }

    function handleStickerUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {
          currentStickerTexture = new THREE.Texture(img);
          currentStickerTexture.needsUpdate = true;
          
          decalMaterial.uniforms.decalTexture.value = currentStickerTexture;
          decalMaterial.uniforms.useDecal.value = true;
          updateDecal();
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    }

    function updateDecal() {
      if (!decalMaterial) return;
      
      const posX = parseFloat(document.getElementById('position-x').value);
      const posY = parseFloat(document.getElementById('position-y').value);
      const scale = parseFloat(document.getElementById('scale').value);
      
      decalMaterial.uniforms.decalPosition.value.set(posX, posY);
      decalMaterial.uniforms.decalScale.value = scale;
      decalMaterial.needsUpdate = true;
    }

    function createFallbackModel() {
      const geometry = new THREE.BoxGeometry(1, 1, 1);
      const material = new THREE.MeshBasicMaterial({ color: 0x4361ee });
      hoodieModel = new THREE.Mesh(geometry, material);
      scene.add(hoodieModel);
      
      document.getElementById('loading-overlay').style.display = 'none';
    }

    function updateStatus(msg) {
      document.getElementById('status').textContent = msg;
      console.log(msg);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      if (mixer) mixer.update(delta);
      controls.update();
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
