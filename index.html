<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Hoodie Viewer with Position Buttons</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; background: #1e1e2e; }
    #viewer { width: 100vw; height: 100vh; }
    #controls {
      position: absolute; top: 10px; left: 10px; z-index: 100;
      background: rgba(30, 30, 46, 0.8); padding: 15px; border-radius: 10px;
      max-height: 80vh; overflow-y: auto; width: 320px;
      backdrop-filter: blur(10px); border: 1px solid #313244;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    }
    #loading-overlay {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(17, 17, 27, 0.95); display: flex; flex-direction: column;
      justify-content: center; align-items: center; color: #cdd6f4; z-index: 100;
    }
    .spinner {
      width: 50px; height: 50px; border: 5px solid rgba(205, 214, 244, 0.2);
      border-radius: 50%; border-top-color: #89b4fa;
      animation: spin 1s ease-in-out infinite; margin-bottom: 20px;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    #status { margin-top: 15px; font-size: 1.1em; text-align: center; }
    #uv-display {
      position: absolute; bottom: 10px; left: 10px; z-index: 100;
      background: rgba(30, 30, 46, 0.8); padding: 12px 15px; border-radius: 8px;
      font-family: monospace; font-size: 14px; color: #cdd6f4;
      backdrop-filter: blur(5px); border: 1px solid #313244;
    }
    #uv-region-display {
      position: absolute; bottom: 10px; right: 10px; z-index: 100;
      background: rgba(30, 30, 46, 0.8); padding: 15px; border-radius: 8px;
      width: 220px; height: 220px; backdrop-filter: blur(5px);
      border: 1px solid #313244; box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }
    #uv-region-title {
      color: #cdd6f4; text-align: center; margin-bottom: 10px;
      font-size: 14px; font-weight: bold;
    }
    #uv-region-display canvas {
      width: 100%; height: 100%; border-radius: 5px;
    }
    .sticker-controls {
      border: 1px solid #45475a; padding: 15px; margin-top: 15px;
      border-radius: 8px; background: rgba(49, 50, 68, 0.6);
    }
    .sticker-header {
      display: flex; justify-content: space-between;
      margin-bottom: 10px; font-weight: bold; color: #89b4fa;
      align-items: center;
    }
    .remove-sticker {
      color: #f38ba8; cursor: pointer; font-size: 1.5em;
      padding: 0 8px; border-radius: 4px; background: rgba(243, 139, 168, 0.1);
    }
    .remove-sticker:hover { background: rgba(243, 139, 168, 0.2); }
    .active-sticker {
      background: rgba(137, 180, 250, 0.15);
      border: 1px solid #89b4fa;
    }
    #add-sticker-btn {
      margin-top: 15px; padding: 8px 15px;
      background: #89b4fa; color: #1e1e2e;
      border: none; border-radius: 6px;
      cursor: pointer; font-weight: bold;
      width: 100%; transition: all 0.2s;
    }
    #add-sticker-btn:hover {
      background: #74c7ec; transform: translateY(-2px);
      box-shadow: 0 4px 10px rgba(137, 180, 250, 0.3);
    }
    .position-controls {
      margin: 10px 0;
    }
    .position-controls label {
      display: block; color: #a6adc8; margin-bottom: 5px;
      font-size: 14px;
    }
    input[type="range"] {
      width: 100%; margin: 5px 0;
      background: #313244; height: 6px;
      border-radius: 3px; outline: none;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px; height: 16px;
      border-radius: 50%;
      background: #89b4fa;
      cursor: pointer;
    }
    .quick-positions {
      display: flex; gap: 8px; flex-wrap: wrap;
      margin-top: 15px;
    }
    .pos-btn {
      flex: 1; min-width: 60px;
      padding: 6px 8px; background: #45475a;
      color: #cdd6f4; border: none;
      border-radius: 5px; cursor: pointer;
      font-size: 12px; text-align: center;
      transition: all 0.2s;
    }
    .pos-btn:hover {
      background: #89b4fa; color: #1e1e2e;
      transform: translateY(-2px);
    }
    .app-title {
      color: #cdd6f4; text-align: center;
      margin: 0 0 15px 0; font-size: 1.4em;
      text-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
    .app-subtitle {
      color: #a6adc8; text-align: center;
      margin: 0 0 20px 0; font-size: 0.9em;
    }
    .instructions {
      color: #a6adc8; font-size: 0.85em;
      margin-top: 15px; padding: 10px;
      background: rgba(49, 50, 68, 0.5);
      border-radius: 6px;
    }
    .instructions ul {
      padding-left: 20px; margin: 10px 0;
    }
    .instructions li {
      margin-bottom: 8px;
    }
    .color-preview {
      width: 20px; height: 20px;
      border-radius: 4px; display: inline-block;
      margin-left: 8px; vertical-align: middle;
      border: 1px solid #313244;
    }
    .color-control {
      display: flex; align-items: center;
      margin: 10px 0;
    }
    .color-control label {
      flex: 1; color: #a6adc8;
    }
  </style>
</head>
<body>
  <div id="controls">
    <h2 class="app-title">3D Hoodie Customizer</h2>
    <p class="app-subtitle">Add and position stickers on the hoodie</p>
    
    <div id="sticker-controls-container">
      <!-- Sticker controls will be added here dynamically -->
    </div>
    <button id="add-sticker-btn">+ Add New Sticker</button>
    
    <div class="instructions">
      <strong>How to use:</strong>
      <ul>
        <li>Add a sticker using the button above</li>
        <li>Upload your own image or use the default</li>
        <li>Adjust position, scale, and rotation</li>
        <li>Use quick position buttons for placement</li>
        <li>Drag to rotate the hoodie 3D view</li>
      </ul>
    </div>
  </div>
  
  <div id="uv-display">
    Current UV: (0.50, 0.50)
  </div>
  
  <div id="uv-region-display">
    <div id="uv-region-title">Hoodie Placement Preview</div>
    <canvas id="uv-region-canvas"></canvas>
  </div>
  
  <div id="loading-overlay">
    <div class="spinner"></div>
    <div id="status">Loading 3D Hoodie Viewer...</div>
  </div>
  <div id="viewer"></div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';

    let scene, camera, renderer, controls, hoodieModel, mixer, clock;
    let decalMaterial, baseTexture;
    let uvRegionCanvas, uvRegionCtx;
    const uvRegions = [{
      id: 'front',         // Internal identifier (must be unique)
      name: 'Front Main',  // Display name shown in UI
      u: 0.5,             // Horizontal center position (0-1)
      v: 0.5,             // Vertical center position (0-1)
      width: 0.3,         // Width of the region (0-1)
      height: 0.4         // Height of the region (0-1)
    }];

    // Predefined positions for the quick buttons
    const POSITIONS = {
      front: { x: 1.50, y: 1.32, name: "Front" },
      back: { x: 0.25, y: 1.38, name: "Back" },
      right: { x: 1.41, y: -0.21, name: "Right Sleeve" },
      left: { x: 0.81, y: -0.51, name: "Left Sleeve" },
      hood: { x: -0.50, y: -0.20, name: "Hood" }
    };

    // Array to store all stickers
    let stickers = [];
    let activeStickerIndex = 0;
    const MAX_DECALS = 10; // Maximum number of decals we support

    init();

    function init() {
      // Setup scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1a1b26);
      scene.fog = new THREE.Fog(0x1a1b26, 10, 20);

      // Setup camera
      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 1.5, 4);

      // Setup renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio || 1);
      renderer.shadowMap.enabled = true;
      document.getElementById('viewer').appendChild(renderer.domElement);

      // Lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(3, 5, 2);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 1024;
      directionalLight.shadow.mapSize.height = 1024;
      scene.add(directionalLight);

      // Add a subtle fill light
      const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
      fillLight.position.set(-3, 2, 2);
      scene.add(fillLight);

      // Add a rim light
      const rimLight = new THREE.DirectionalLight(0xffffff, 0.5);
      rimLight.position.set(-1, 3, -3);
      scene.add(rimLight);

      // Controls
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = 2;
      controls.maxDistance = 10;

      // Clock for animations
      clock = new THREE.Clock();

      // Setup UV region display
      uvRegionCanvas = document.getElementById('uv-region-canvas');
      uvRegionCanvas.width = 200;
      uvRegionCanvas.height = 200;
      uvRegionCtx = uvRegionCanvas.getContext('2d');
      drawUVRegion();

      // Add event listener for adding new stickers
      document.getElementById('add-sticker-btn').addEventListener('click', addNewSticker);

      // Load model
      loadModel();

      // Start animation loop
      animate();

      // Handle window resize
      window.addEventListener('resize', onWindowResize);
      
      // Add ground plane
      addGround();
    }
    
    function addGround() {
      const groundGeometry = new THREE.PlaneGeometry(20, 20);
      const groundMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x313244,
        roughness: 0.8,
        metalness: 0.2
      });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = -1.5;
      ground.receiveShadow = true;
      scene.add(ground);
    }

    function drawUVRegion() {
      const region = uvRegions[0];
      const canvasSize = 200;
      const padding = 10;
      
      // Clear canvas
      uvRegionCtx.clearRect(0, 0, canvasSize, canvasSize);
      
      // Draw background
      uvRegionCtx.fillStyle = '#313244';
      uvRegionCtx.fillRect(0, 0, canvasSize, canvasSize);
      
      // Draw grid
      uvRegionCtx.strokeStyle = '#45475a';
      uvRegionCtx.lineWidth = 1;
      for (let i = 0; i <= 10; i++) {
        uvRegionCtx.beginPath();
        uvRegionCtx.moveTo(i * 20, 0);
        uvRegionCtx.lineTo(i * 20, canvasSize);
        uvRegionCtx.stroke();
        
        uvRegionCtx.beginPath();
        uvRegionCtx.moveTo(0, i * 20);
        uvRegionCtx.lineTo(canvasSize, i * 20);
        uvRegionCtx.stroke();
      }
      
      // Draw region outline
      uvRegionCtx.strokeStyle = '#89b4fa';
      uvRegionCtx.lineWidth = 2;
      uvRegionCtx.beginPath();
      uvRegionCtx.rect(
        padding + (region.u - region.width/2) * (canvasSize - 2*padding),
        padding + (1 - region.v - region.height/2) * (canvasSize - 2*padding),
        region.width * (canvasSize - 2*padding),
        region.height * (canvasSize - 2*padding)
      );
      uvRegionCtx.stroke();
      
      // Draw center point
      uvRegionCtx.fillStyle = '#f38ba8';
      uvRegionCtx.beginPath();
      uvRegionCtx.arc(
        padding + region.u * (canvasSize - 2*padding),
        padding + (1 - region.v) * (canvasSize - 2*padding),
        4, 0, Math.PI * 2
      );
      uvRegionCtx.fill();
      
      // Draw all sticker positions
      stickers.forEach((sticker, index) => {
        const posX = sticker.position.x;
        const posY = sticker.position.y;
        const isActive = index === activeStickerIndex;
        
        uvRegionCtx.fillStyle = isActive ? '#a6e3a1' : '#89b4fa';
        uvRegionCtx.beginPath();
        uvRegionCtx.arc(
          padding + (region.u + posX) * (canvasSize - 2*padding),
          padding + (1 - region.v - posY) * (canvasSize - 2*padding),
          6, 0, Math.PI * 2
        );
        uvRegionCtx.fill();
        
        // Draw scale indicator
        const scale = sticker.scale * 20;
        uvRegionCtx.strokeStyle = isActive ? '#a6e3a1' : '#89b4fa';
        uvRegionCtx.lineWidth = 2;
        uvRegionCtx.beginPath();
        uvRegionCtx.arc(
          padding + (region.u + posX) * (canvasSize - 2*padding),
          padding + (1 - region.v - posY) * (canvasSize - 2*padding),
          scale, 0, Math.PI * 2
        );
        uvRegionCtx.stroke();
      });
      
      // Update UV display for active sticker
      if (stickers.length > 0) {
        const activeSticker = stickers[activeStickerIndex];
        updateUVDisplay(0.5 + activeSticker.position.x, 0.5 + activeSticker.position.y);
      }
    }

    function updateUVDisplay(u, v) {
      document.getElementById('uv-display').textContent = 
        `Current UV: (${u.toFixed(2)}, ${v.toFixed(2)})`;
    }

    async function loadModel() {
      updateStatus('Loading hoodie model...');
      
      try {
        // In a real app, we would load the actual model
        // For this demo, we'll create a placeholder hoodie model
        createFallbackModel();
        
        // Create a default white texture
        baseTexture = createDefaultTexture();
        
        // Create decal material
        decalMaterial = createDecalMaterial(baseTexture);
        
        // Apply material to all meshes
        hoodieModel.traverse((child) => {
          if (child.isMesh) {
            child.material = decalMaterial;
          }
        });

        // Position model
        hoodieModel.position.y = -0.5;
        hoodieModel.scale.set(0.8, 0.8, 0.8);
        hoodieModel.traverse(child => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
          }
        });

        // Hide loading overlay
        setTimeout(() => {
          document.getElementById('loading-overlay').style.display = 'none';
        }, 1000);
        
        // Add a default sticker to start with
        addNewSticker();
      } catch (error) {
        updateStatus('Failed to load model');
        console.error(error);
        createFallbackModel();
      }
    }

    function createDefaultTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = canvas.height = 512;
      const ctx = canvas.getContext('2d');
      
      // Create gradient background
      const gradient = ctx.createLinearGradient(0, 0, 512, 512);
      gradient.addColorStop(0, '#313244');
      gradient.addColorStop(1, '#1e1e2e');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, 512, 512);
      
      // Draw hoodie pattern
      ctx.fillStyle = '#45475a';
      ctx.fillRect(150, 100, 212, 250); // Body
      ctx.fillRect(100, 350, 312, 80); // Bottom
      ctx.fillRect(80, 100, 70, 150); // Left sleeve
      ctx.fillRect(362, 100, 70, 150); // Right sleeve
      ctx.fillRect(150, 30, 212, 80); // Hood
      
      return new THREE.CanvasTexture(canvas);
    }

    function createDecalMaterial(baseTexture) {
      // Create uniforms object
      const uniforms = {
        baseTexture: { value: baseTexture },
        decalCount: { value: 0 }
      };

      // Add texture slots for up to MAX_DECALS decals
      for (let i = 0; i < MAX_DECALS; i++) {
        uniforms[`decalTexture${i}`] = { value: null };
        uniforms[`decalPosition${i}`] = { value: new THREE.Vector2(0, 0) };
        uniforms[`decalScale${i}`] = { value: 1.0 };
        uniforms[`decalRotation${i}`] = { value: 0.0 };
      }

      // Generate the fragment shader dynamically based on MAX_DECALS
      let fragmentShader = `
        uniform sampler2D baseTexture;
        uniform int decalCount;
        varying vec2 vUV;
        
        // Declare all decal uniforms
      `;

      // Add uniform declarations
      for (let i = 0; i < MAX_DECALS; i++) {
        fragmentShader += `
          uniform sampler2D decalTexture${i};
          uniform vec2 decalPosition${i};
          uniform float decalScale${i};
          uniform float decalRotation${i};
        `;
      }

      fragmentShader += `
        void main() {
          vec4 baseColor = texture2D(baseTexture, vUV);
          vec4 finalColor = baseColor;
          
          // Apply decals in order
      `;

      // Add decal application logic
      for (let i = 0; i < MAX_DECALS; i++) {
        fragmentShader += `
          if (decalCount > ${i}) {
            vec2 center = vec2(0.5);
            vec2 uv = vUV - center;
            
            // Apply rotation
            float cosRot = cos(decalRotation${i});
            float sinRot = sin(decalRotation${i});
            uv = vec2(
              uv.x * cosRot - uv.y * sinRot,
              uv.x * sinRot + uv.y * cosRot
            );
            
            // Apply scale and position
            uv = uv / decalScale${i} + decalPosition${i} + center;
            
            if (uv.x >= 0.0 && uv.x <= 1.0 && uv.y >= 0.0 && uv.y <= 1.0) {
              vec4 decalColor = texture2D(decalTexture${i}, uv);
              finalColor = mix(finalColor, decalColor, decalColor.a);
            }
          }
        `;
      }

      fragmentShader += `
          gl_FragColor = finalColor;
        }
      `;

      const vertexShader = `
        varying vec2 vUV;
        void main() {
          vUV = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `;

      return new THREE.ShaderMaterial({
        uniforms: uniforms,
        vertexShader: vertexShader,
        fragmentShader: fragmentShader,
        transparent: true
      });
    }

    function addNewSticker() {
      if (stickers.length >= MAX_DECALS) {
        alert(`Maximum number of stickers (${MAX_DECALS}) reached`);
        return;
      }

      const stickerId = 'sticker-' + Date.now();
      const newSticker = {
        id: stickerId,
        texture: null,
        position: new THREE.Vector2(0, 0),
        scale: 0.5,
        rotation: 0,
        element: null,
        index: stickers.length,
        color: new THREE.Color(0xf38ba8)
      };
      
      stickers.push(newSticker);
      activeStickerIndex = stickers.length - 1;
      
      createStickerControls(newSticker);
      updateDecalUniforms();
      drawUVRegion();
    }

    function createStickerControls(sticker) {
      const container = document.getElementById('sticker-controls-container');
      
      const stickerDiv = document.createElement('div');
      stickerDiv.className = 'sticker-controls';
      stickerDiv.id = sticker.id + '-controls';
      if (stickers.length - 1 === activeStickerIndex) {
        stickerDiv.classList.add('active-sticker');
      }
      
      stickerDiv.innerHTML = `
        <div class="sticker-header">
          <span>Sticker ${sticker.index + 1}</span>
          <span class="remove-sticker" data-id="${sticker.id}">×</span>
        </div>
        
        <div class="position-controls">
          <label>Position</label>
          <input type="range" class="position-x" min="-1" max="1" step="0.01" value="0" data-id="${sticker.id}">
          <input type="range" class="position-y" min="-1" max="1" step="0.01" value="0" data-id="${sticker.id}">
        </div>
        
        <div class="position-controls">
          <label>Scale: <span>${sticker.scale.toFixed(2)}</span></label>
          <input type="range" class="scale" min="0.1" max="2" step="0.05" value="${sticker.scale}" data-id="${sticker.id}">
        </div>
        
        <div class="position-controls">
          <label>Rotation: <span>${(sticker.rotation * 180 / Math.PI).toFixed(0)}°</span></label>
          <input type="range" class="rotation" min="0" max="6.28" step="0.1" value="${sticker.rotation}" data-id="${sticker.id}">
        </div>
        
        <div class="quick-positions">
          <button class="pos-btn" data-pos="front">Front</button>
          <button class="pos-btn" data-pos="back">Back</button>
          <button class="pos-btn" data-pos="right">Right</button>
          <button class="pos-btn" data-pos="left">Left</button>
          <button class="pos-btn" data-pos="hood">Hood</button>
        </div>
      `;
      
      container.appendChild(stickerDiv);
      sticker.element = stickerDiv;
      
      // Add event listeners
      stickerDiv.querySelector('.position-x').addEventListener('input', (e) => updateStickerPosition(e, sticker.id, 'x'));
      stickerDiv.querySelector('.position-y').addEventListener('input', (e) => updateStickerPosition(e, sticker.id, 'y'));
      stickerDiv.querySelector('.scale').addEventListener('input', (e) => updateStickerScale(e, sticker.id));
      stickerDiv.querySelector('.rotation').addEventListener('input', (e) => updateStickerRotation(e, sticker.id));
      stickerDiv.querySelector('.remove-sticker').addEventListener('click', (e) => removeSticker(e, sticker.id));
      
      // Add quick position buttons listeners
      const posButtons = stickerDiv.querySelectorAll('.pos-btn');
      posButtons.forEach(btn => {
        btn.addEventListener('click', (e) => {
          const pos = btn.dataset.pos;
          applyQuickPosition(sticker.id, pos);
        });
      });
      
      // Make sticker active when clicked
      stickerDiv.addEventListener('click', () => {
        setActiveSticker(sticker.id);
      });
    }

    function applyQuickPosition(stickerId, positionKey) {
      const pos = POSITIONS[positionKey];
      if (!pos) return;
      
      const stickerIndex = stickers.findIndex(s => s.id === stickerId);
      if (stickerIndex === -1) return;
      
      const sticker = stickers[stickerIndex];
      
      // Calculate the offset from the center (0.5, 0.5)
      sticker.position.x = pos.x - 0.5;
      sticker.position.y = pos.y - 0.5;
      
      // Update the sliders
      const stickerDiv = sticker.element;
      stickerDiv.querySelector('.position-x').value = sticker.position.x;
      stickerDiv.querySelector('.position-y').value = sticker.position.y;
      
      // Update the material and display
      updateDecalUniforms();
      drawUVRegion();
      
      // Show a notification
      showNotification(`Sticker placed on ${pos.name}`);
    }
    
    function showNotification(message) {
      const notification = document.createElement('div');
      notification.style.position = 'absolute';
      notification.style.top = '20px';
      notification.style.right = '20px';
      notification.style.backgroundColor = '#89b4fa';
      notification.style.color = '#1e1e2e';
      notification.style.padding = '10px 20px';
      notification.style.borderRadius = '5px';
      notification.style.zIndex = '1000';
      notification.style.fontWeight = 'bold';
      notification.style.boxShadow = '0 4px 10px rgba(0,0,0,0.2)';
      notification.textContent = message;
      
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.style.opacity = '0';
        notification.style.transition = 'opacity 0.5s';
        setTimeout(() => {
          document.body.removeChild(notification);
        }, 500);
      }, 2000);
    }

    function setActiveSticker(stickerId) {
      const index = stickers.findIndex(s => s.id === stickerId);
      if (index !== -1) {
        activeStickerIndex = index;
        
        // Update UI to show active sticker
        document.querySelectorAll('.sticker-controls').forEach(div => {
          div.classList.remove('active-sticker');
        });
        document.getElementById(stickerId + '-controls').classList.add('active-sticker');
        
        drawUVRegion();
      }
    }

    function updateStickerPosition(event, stickerId, axis) {
      const value = parseFloat(event.target.value);
      const stickerIndex = stickers.findIndex(s => s.id === stickerId);
      
      if (stickerIndex !== -1) {
        if (axis === 'x') {
          stickers[stickerIndex].position.x = value;
        } else {
          stickers[stickerIndex].position.y = value;
        }
        
        updateDecalUniforms();
        drawUVRegion();
      }
    }

    function updateStickerScale(event, stickerId) {
      const value = parseFloat(event.target.value);
      const stickerIndex = stickers.findIndex(s => s.id === stickerId);
      
      if (stickerIndex !== -1) {
        stickers[stickerIndex].scale = value;
        
        // Update the label
        const stickerDiv = stickerIndex !== -1 ? stickers[stickerIndex].element : null;
        if (stickerDiv) {
          stickerDiv.querySelector('.scale + label span').textContent = value.toFixed(2);
        }
        
        updateDecalUniforms();
        drawUVRegion();
      }
    }

    function updateStickerRotation(event, stickerId) {
      const value = parseFloat(event.target.value);
      const stickerIndex = stickers.findIndex(s => s.id === stickerId);
      
      if (stickerIndex !== -1) {
        stickers[stickerIndex].rotation = value;
        
        // Update the label
        const stickerDiv = stickerIndex !== -1 ? stickers[stickerIndex].element : null;
        if (stickerDiv) {
          const degrees = (value * 180 / Math.PI).toFixed(0);
          stickerDiv.querySelector('.rotation + label span').textContent = `${degrees}°`;
        }
        
        updateDecalUniforms();
      }
    }

    function removeSticker(event, stickerId) {
      event.stopPropagation();
      
      const stickerIndex = stickers.findIndex(s => s.id === stickerId);
      if (stickerIndex !== -1) {
        // Remove from DOM
        const element = document.getElementById(stickerId + '-controls');
        if (element) element.remove();
        
        // Remove from array
        stickers.splice(stickerIndex, 1);
        
        // Update indices of remaining stickers
        stickers.forEach((sticker, index) => {
          sticker.index = index;
          if (sticker.element) {
            sticker.element.querySelector('.sticker-header span:first-child').textContent = `Sticker ${index + 1}`;
          }
        });
        
        // Update active sticker index if needed
        if (activeStickerIndex >= stickerIndex) {
          activeStickerIndex = Math.max(0, activeStickerIndex - 1);
        }
        
        // Update the material
        updateDecalUniforms();
        drawUVRegion();
      }
    }

    function updateDecalUniforms() {
      if (!decalMaterial) return;
      
      decalMaterial.uniforms.decalCount.value = stickers.length;
      
      // Reset all uniforms first
      for (let i = 0; i < MAX_DECALS; i++) {
        decalMaterial.uniforms[`decalTexture${i}`].value = null;
        decalMaterial.uniforms[`decalPosition${i}`].value.set(0, 0);
        decalMaterial.uniforms[`decalScale${i}`].value = 1.0;
        decalMaterial.uniforms[`decalRotation${i}`].value = 0.0;
      }
      
      // Update active stickers
      stickers.forEach((sticker, index) => {
        // Create a texture for the sticker
        if (!sticker.texture) {
          sticker.texture = createStickerTexture(sticker.color);
        }
        
        decalMaterial.uniforms[`decalTexture${index}`].value = sticker.texture;
        decalMaterial.uniforms[`decalPosition${index}`].value.copy(sticker.position);
        decalMaterial.uniforms[`decalScale${index}`].value = sticker.scale;
        decalMaterial.uniforms[`decalRotation${index}`].value = sticker.rotation;
      });
      
      decalMaterial.needsUpdate = true;
    }
    
    function createStickerTexture(color) {
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 256;
      const ctx = canvas.getContext('2d');
      
      // Draw background
      ctx.fillStyle = `rgb(${color.r * 255}, ${color.g * 255}, ${color.b * 255})`;
      ctx.fillRect(0, 0, 256, 256);
      
      // Draw a simple design
      ctx.fillStyle = 'white';
      ctx.font = 'bold 100px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('✪', 128, 128);
      
      return new THREE.CanvasTexture(canvas);
    }

    function createFallbackModel() {
      // Create a simple hoodie model using basic geometries
      const group = new THREE.Group();
      
      // Body
      const bodyGeometry = new THREE.BoxGeometry(1.5, 2, 0.5);
      const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x313244 });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.y = 0.5;
      group.add(body);
      
      // Hood
      const hoodGeometry = new THREE.ConeGeometry(0.8, 0.8, 4);
      hoodGeometry.rotateX(Math.PI);
      const hoodMaterial = new THREE.MeshStandardMaterial({ color: 0x45475a });
      const hood = new THREE.Mesh(hoodGeometry, hoodMaterial);
      hood.position.y = 1.7;
      hood.position.z = 0.1;
      hood.rotation.y = Math.PI / 4;
      group.add(hood);
      
      // Sleeves
      const sleeveGeometry = new THREE.CylinderGeometry(0.2, 0.2, 1, 16);
      sleeveGeometry.rotateZ(Math.PI / 2);
      
      const leftSleeve = new THREE.Mesh(sleeveGeometry, hoodMaterial);
      leftSleeve.position.set(-1, 0.8, 0);
      group.add(leftSleeve);
      
      const rightSleeve = new THREE.Mesh(sleeveGeometry, hoodMaterial);
      rightSleeve.position.set(1, 0.8, 0);
      group.add(rightSleeve);
      
      // Add the model to the scene
      hoodieModel = group;
      scene.add(hoodieModel);
    }

    function updateStatus(msg) {
      document.getElementById('status').textContent = msg;
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      if (mixer) mixer.update(delta);
      controls.update();
      renderer.render(scene, camera);
      
      // Rotate the hoodie slowly
      if (hoodieModel) {
        hoodieModel.rotation.y += 0.002;
      }
    }
  </script>
</body>
</html>
